## Стандартная библиотека шаблонов

В этой и двух последующих лекциях мы затронем вопросы, связанные с **STL** - стандартной библиотекой шаблонов, входящей в состав стандартной библиотеки языка С++. Не будет преувеличением сказать, что STL составляет ядро стандартной библиотеки и является важнейшей ее частью, широко используемой в промышленном программировании.

### Общие сведения и состав STL

- контейнеры (хранение объектов),
- итераторы (доступ к элементам контейнера, инструмент для перебора элементов),
- алгоритмы (обработка элементов),
- контейнерные адаптеры (обёртки над контейнерами)
- функциональные объекты, функторы (обобщение функций)


**Контейнеры** предназначены для управления коллекциями объектов определенного типа. У каждой разновидности контейнеров имеются свои достоинства и недостатки.

**Итераторы** предназначены для перебора элементов в коллекциях объектов (контейнерах или их подмножествах). Главное достоинство итераторов - они предоставляют небольшой, но стандартный интерфейс, подходящий для любого типа контейнера.

**Алгоритмы** предназначены для обработки элементов коллекций. (Поиск, сортировку, модификацию и т.д.). В работе алгоритмов используются итераторы. Алгоритм достаточно запрограммировать только один раз для обобщенного контейнера, потому что интерфейс итераторов является общим для всех контейнеров.

![](img/stl-1.png)
Рисунок 1. Архитектура библиотеки

Все компоненты стандартной библиотеки С++ располагаются в пространстве имен **std**.

Компоненты STL оформлены в виде шаблонов и поэтому могут использоваться с произвольными типами элементов.

STL формирует архитектуру для включения других классов коллекций и алгоритмов, работающих в сочетании с существующими коллекциями и алгоритмами.

STL - хороший пример концепции унифицированного (обобщенного) программирования.


### Общие сведения о контейнерах

Контейнеры библиотеки STL можно разделить на два типа:

- последовательные (линейные),
- ассоциативные (нелинейные),

Общие вложенные типы

- Container::value_type
- Container::iterator
- Container::const_iterator


Контейнеры должны поддерживать *семантику значений* вместо *ссылочной семантики*. При вставке элемента контейнер создает его внутреннюю копию, вместо того чтобы сохранять ссылку на внешний объект.
Следовательно, элементы контейнера STL должны поддерживать копирование. 

Элементы в контейнере располагаются в определенном порядке. Это означает, что при повторном переборе с применением итератора порядок перебора элементов должен остаться прежним.
В каждом типе контейнера определены операции, возвращающие итераторы для перебора элементов.

В общем случае операции с элементами контейнеров небезопасны. Вызывающая сторона должна проследить за тем, чтобы параметры операции соответствовали требованиям.


### Общие методы контейнеров

|            Метод             |        Назначение   |
|------------------------------|----------------------------------------------------|
| ContType  c                  | Создает пустой контейнер, не содержащий элементов  |
| ContType c1(c2)              | Создает копию контейнера того же типа              |
| ContType c(beg,end)          | Создает контейнер и инициализирует его копиями всех элементов в интервале [beg, end) |
| c.~ContType()                | Удаляет все элементы и освобождает память          |
| c.size()                     | Возвращает фактическое количество элементов        |
| c.empty()                    | Проверяет, пуст ли контейнер (эквивалент size()==0, но иногда выполняется быстрее) |
| c.max_size()                 | Возвращает максимально возможное количество элементов (в общем случае, совпадает c максимальным значением типа индекса) |
| c1 == 2                      | Проверяет равенство с1 и с2  |
| c1 != c2                     | Проверяет неравенство с1 и с2 (эквивалентно !(с1 == с2) ) |
| c1 < c2                      | Проверяет, что c1 меньше c2 (лексикографически) |
| c1 > c2                      | Проверяет, что c1 больше c2 (эквивалент c2 < c1 )  |
| c1 <= c2                     | Проверяет, что c1 не больше с2 (эквивалент !(с2 < с1) ) |
| c1 >= c2                     | Проверяет, что c1 не меньше с2 (эквивалент !(с1 < с2)) |
| c1 = c2                      | Присваивает с1 все элементы с2  |
| c1.swap(c2)                  | Меняет местами содержимое с1 и с2 (гораздо эффективнее, чем =)|
| swap(c1,c2)                  | То же, но в форме глобальной функции  |
| c.begin()                    | Возвращает итератор для первого элемента |
| c.end()                      | Возвращает итератор для позиции за последним элементом |
| c.rbegin()                   | Возвращает обратный итератор для первого элемента при переборе в обратном направлении |
| c.rend()                     | Возвращает обратный итератор для позиции за последним элементом при переборе в обратном направлении |
| c.insert(pos,elem)           | Вставляет копию elem  (с разными вариантами возвращаемого значения и интерпретацией первого аргумента)  |
| c.erase(beg,end)             | Удаляет все элементы из интервала [beg, end) (некоторые контейнеры воэвращакэт следующий элемент после удаленного интервала) |
| c.clear()                    | Удаляет из контейнера все элементы (контейнер остается пустым) |


### Последовательные контейнеры

**Последовательные контейнеры** – упорядоченные коллекции, в которых каждый элемент занимает определенную позицию. Позиция зависит от времени и места вставки, но не связана со значением элемента. 


#### Контейнер *array*

Контейнер **array** является оберткой над обычным статическим массивом. Размер контейнера определяется во время объявления и в дальнейшем не может быть изменен.

```c++
#include <array>
std::array<std::string, 3> a = {"One", "Two", "Three"};
std::cout << a.size() << std::endl;
std::cout << a[1] << std::endl;
```

#### Контейнер *vector*

Наиболее популярный последовательный контейнер. Обеспечивает быструю вставку и удаление элемента с одного конца.

![](img/vec-1.png)
Рисунок 2. Схематическое изображение вектора

- Элементы вектора копируются во внутренний динамический массив.
- Вектор является упорядоченной коллекцией, т.е. элементы всегда хранятся в определенном порядке.
- Вектор обеспечивает произвольный доступ к своим элементам. Обращение к любому элементу с известной позицией выполняется напрямую и с постоянным временем.
- Итераторы векторов являются итераторами произвольного доступа, что позволяет применять к векторам все алгоритмы STL.
- Операции присоединения и удаления элементов в конце вектора выполняются с высоким быстродействием.
- Если элементы вставляются или удаляются в середине или в начале, быстродействие снижается, поскольку все элементы в последующих позициях приходится перемещать на новое место. На самом деле для каждого последующего элемента вызывается оператор присваивания.
- Один из способов повышения быстродействия векторов заключается в выделении для вектора большего объема памяти, чем необходимо для хранения всех элементов
- Векторы поддерживают стандартные операции проверки размера **size()**, **empty()** и  **max_size()**.
- Функция **capacity()** возвращающая максимальное количество элементов, которые могут храниться в текущей выделенной памяти. Если количество элементов превысит это значение, вектору придется перераспределить свою внутреннюю намять.
- Емкость вектора необходимо учитывать по двум причинам:
  - в результате перераспределения памяти становятся недействительными все ссылки, указатели и итераторы элементов вектора;
  - на перераспределение памяти требуется время.


Чтобы предотвратить перераспределение памяти, можно заранее зарезервировать некоторую емкость функцией **reserve()**.

```c++
std::vector<int> v; // Создание пустого вектора
v.reserve(80);      // Резервирование памяти для 80 элементов (БЕЗ вызова конструкторов в отличии от resize().)
```

Либо можно проинициализировать вектор достаточным количеством элементов, для чего конструктору передается начальный размер вектора:

```c++
std::vector<T> v(5); // Создание вектора и его инициализация пятью значениями (с пятикратным вызовом конструктора по умолчанию типа T
```

Емкость вектора напрямую никогда не уменьшается. 

```c++
template <class T>
void shrinkCapacity(std::vector<T>& v)
{
    std::vector<T> tmp(v); // Копирование элементов в новый вектор
    v.swap(tmp);           // Перестановка внутренних данных векторов
} 
```

После вызова функции **swap()** все ссылки, указатели и итераторы продолжают ссылаться на первоначально выделенную память.
Т.е. все ссылки, указатели и итераторы становятся недействительными.

Некоторые важные операции над вектором:

|            Метод             |        Назначение   |
|------------------------------|----------------------------------------------------|
| c.at(idx)                    | Возвращает элемент с индексом idx (при недопустимом значении индекса генерируется исключение out_of_range) |
| c[idx]                       | Возвращает элемент с индексом idx (без интервальной проверки!) |
| c.front()                    | Возвращает первый элемент (без проверки его существования!) |
| c.back()                     | Возвращает последний элемент (без проверки его существования!) |
| c.begin()                    | Возвращает итератор произвольного доступа для первого элемента |
| c.end()                      | Возвращает итератор произвольного доступа для позиции за последним элементом |
| c.rbegin()                   | Возвращает обратный итератор для первого элемента при переборе в обратном направлении |
| c.rend()                     | Возвращает обратный итератор для позиции за последним элементом при переборе в обратном направлении |
| c.insert(pos, elem)          | Вставляет в позицию итератора pos копию элемента elem и возвращает позицию нового элемента  |
| c.insert(pos, n, elem)       | Вставляет в позицию итератора pos n копий элемента elem (и не возвращает значения) |
| c.insert(pos, beg, end)      | Вставляет копию всех элементов интервала [beg,end) в позицию итератора pos (и не возвращает значения)  |
| c.push_back(elem)            | Присоединяет копию elem в конец вектора  |
| c.resize(num)                | Приводит контейнер к размеру num (если size() при этом увеличивается, новые элементы создаются своим конструктором по умолчанию) |
| c.resize(num, elem)          | Приводит контейнер к размеру num (если size() при этом увеличивается, новые элементы создаются как копии elem)  |
| c.pop_back()                 | Удаляет последний элемент (не возвращая его)  |
| c.erase(pos)                 | Удаляет элемент в позиции итератора pos и возвращает позицию следующего элемента |
| c.erase(beg, end)            | Удаляет все элементы из интервала [beg, end) и возвращает позицию следующего элемента  |
| c.clear()                    | Удаляет все элементы (контейнер остается пустым) |


```cpp
std::vector<Elem> coll;
...
// Удаление всех элементов со значением val 
coll.erase(remove(coll.begin(),coll.end(),
                  val),coll.end());
```

```cpp
vector<Elem> coll;
...
// Удаление первого элемента со значением val 
vector<Elem>::iterator pos
    = find(coll.begin(),coll.end(), val);
if (pos != coll.end())
    coll.erase(pos);
```


Итераторы остаются действительными до момента

- вставки
- или удаления элемента с меньшим индексом
- или перераспределения памяти

Согласно стандарту, исключения генерирует только одна функция **at()** - безопасная версия оператора индексирования.


Пример использования вектора:

```cpp
#include <iostream>
#include <vector>
using namespace std;

int main()
{
    vector<int> coll;    // Вектор с целыми элементами

    // Присоединение элементов со значениями от 1 до 6
    for (int i=1; i< = 6; ++i) {
        coll.push_back(i);
    }

    // Вывод элементов, разделенных пробелами
    for (int i=0; i < coll.size(); ++i) {
        cout << coll[i] << ' ';
    }
}
```


#### Контейнер *deque*

Контейнер c возможностью быстрой вставки и удаления элементов на обоих концах за O(1). Реализован как список указателей на массивы фиксированного размера.


#### Контейнер *list*

Двусвязный список. В любом месте контейнера вставка и удаление производятся за O(1).



```c++
std::list<string> strngs {"One", "Two", "Three"}; 
for (std::string & s : strngs)
    std::cout << s << std::endl;
```




